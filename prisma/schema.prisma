generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

// 1. ì±… í‘œì§€ ì´ë¯¸ì§€ ìºì‹œ
model CachedBookCover {
  isbn      String   @id
  imageUrl  String   @map("image_url")
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@map("cached_book_covers")
}

// 2. ë„ì„œê´€ ê¸°ë³¸ ì •ë³´ ìºì‹œ
model CachedLibrary {
  libCode   String   @id @map("lib_code")
  libName   String   @map("lib_name")
  address   String?
  tel       String?
  latitude  Decimal? // Numeric -> Decimal
  longitude Decimal? // Numeric -> Decimal
  homepage  String?
  updatedAt DateTime @default(now()) @updatedAt @map("updated_at")

  @@map("cached_libraries")
}

// 3. ì¸ê¸°ë„ì„œ í†µê³„ ìºì‹œ
model CachedPopularBook {
  id         Int       @id @default(autoincrement())
  category   String    // 'hot_trend', 'new_books' ë“±
  regionCode String    @default("ALL") @map("region_code")
  bookData   Json      @map("book_data") // JSONB
  createdAt  DateTime  @default(now()) @map("created_at")
  expiresAt  DateTime? @map("expires_at")

  @@index([category, regionCode])
  @@map("cached_popular_books")
}

// 4. ìœ ì € í”„ë¡œí•„ (Supabase Auth ì—°ë™)
model UserProfile {
  id        String   @id @map("id") // Supabase Auth User ID (UUID)
  email     String   @unique
  name      String?
  avatarUrl String?  @map("avatar_url")
  provider  String?  // 'kakao', 'google' etc
  userType  String   @default("general") @map("user_type") // 'general' | 'parent'
  hasCompletedOnboarding Boolean @default(false) @map("has_completed_onboarding")
  
  readStamps ReadStamp[]
  childProfiles ChildProfile[]
  
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@map("user_profiles")
}

// 5. ë…ì„œ ê¸°ë¡ (Read Stamp)
model ReadStamp {
  id        String   @id @default(uuid())
  userId    String   @map("user_id")
  isbn      String
  
  // ì±… ë©”íƒ€ë°ì´í„° ìŠ¤ëƒ…ìƒ· (ì±… ì •ë³´ê°€ DBì— ì—†ì„ ê²½ìš° ëŒ€ë¹„)
  title     String
  author    String?
  bookImage String?  @map("book_image")
  
  emoji     String?  // 'ğŸ˜†', 'ğŸ˜­' ë“±
  comment   String?  // í•œì¤„í‰ (ì¶”í›„ í™•ì¥)
  
  isPublic  Boolean  @default(true) @map("is_public") // ê³µê°œ ì—¬ë¶€
  
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")
  
  user      UserProfile @relation(fields: [userId], references: [id], onDelete: Cascade)

  // ìë…€ì—ê²Œ í• ë‹¹(íë ˆì´ì…˜)ëœ ê²½ìš° ì„¤ì •
  childId   String?  @map("child_id")
  child     ChildProfile? @relation(fields: [childId], references: [id])

  // ìœ ì €ë‹¹ ì±… í•˜ë‚˜ì— ìŠ¤íƒ¬í”„ í•˜ë‚˜ (ìë…€ë³„ë¡œë„ êµ¬ë¶„ ê°€ëŠ¥í•˜ë˜, ë¶€ëª¨ ì„œì¬ì—” 1ê°œë§Œ)
  // ë¶€ëª¨ ì„œì¬: childId=null, ìë…€ ì„œì¬: childId=uuid
  // Nullable field in unique index is treated as distinct in Postgres, so (userId, isbn, childId) works.
  @@unique([userId, isbn, childId]) 
  @@index([userId])
  @@index([isbn])
  @@index([childId])
  @@map("read_stamps")
}

// 6. ìë…€ í”„ë¡œí•„ (ë‹¤ìë…€ ì§€ì›)
model ChildProfile {
  id        String   @id @default(uuid())
  userId    String   @map("user_id") 
  name      String   
  birthYear Int      @map("birth_year")
  emoji     String?  @default("ğŸ¥")
  
  readStamps ReadStamp[]
  
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")
  
  user      UserProfile @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("child_profiles")
}
